plot(resources, metric = "usage", steps = TRUE)
par(mfrow = c(3, 2))
plot(arrivals, metric = "activity_time")
plot(arrivals, metric = "waiting_time")
?plot
plot(arrivals, metric = "activity_time", main = "Время обработки тикета")
summary(resources)
source('~/Desktop/simulation/data.R')
# Загрузка весов времени обработки
load_skill_weighted_processing_times = memoise(function(skill_name, type = 'old') {
skill_name_modified = skill_name %>% str_to_lower() %>% str_replace_all(' ', '_')
data = read.csv(str_glue("data/{type}/{str_to_lower(skill)}_processing_time.csv"))
data_refined = remove_outliers(data$processing_time)
data_weighted = table(data_refined) / length(data_refined)
return(list(
original = data$processing_time,
data = data_refined,
weights = data_weighted,
processing_times = as.numeric(names(data_weighted))
))
})
source('~/Desktop/simulation/data.R', echo=TRUE)
full_first_line_data = load_skill_weighted_processing_times('Full first line', 'new')
# Загрузка весов времени обработки
load_skill_weighted_processing_times = memoise(function(skill_name, type = 'old') {
skill_name_modified = skill_name %>% str_to_lower() %>% str_replace_all(' ', '_')
data = read.csv(str_glue("data/{type}/{skill_name_modified}_processing_time.csv"))
data_refined = remove_outliers(data$processing_time)
data_weighted = table(data_refined) / length(data_refined)
return(list(
original = data$processing_time,
data = data_refined,
weights = data_weighted,
processing_times = as.numeric(names(data_weighted))
))
})
full_first_line_data = load_skill_weighted_processing_times('Full first line', 'new')
plot(density(full_first_line_data$data))
full_first_line_data = load_skill_weighted_processing_times('Mobile + IP', 'new')
plot(density(full_first_line_data$data))
styler:::style_active_file()
library(stats)
library(dplyr)
library(simmer)
library(simmer.plot)
library(progress)
source("./data.R")
real_tickets_flow <- get_real_tickets_flow()
skills <- skills_new
set.seed(1234)
#
#
# SIMULATION
#
#
env <- simmer("New line config")
# Определить скилл тикета по вероятности
get_random_skill_id <- function() {
skill <- sample_n(skills, size = 1, weight = skills$probability)
return(skill$id)
}
# Получить объект скилла по id
get_skill_by_id <- function() {
skill_id <- get_attribute(env, "skill_id")
return(skills[skills$id == skill_id, ])
}
# Определить, является ли тикет спамом в соответствии с вероятностью по скиллам
get_random_is_spam <- function() {
skill <- get_skill_by_id()
spam_probabiliy <- skill$spam_probabiliy
is_spam <- base::sample(c(0, 1), size = 1, prob = c(1 - spam_probabiliy, spam_probabiliy))
return(is_spam)
}
# Определить, нужно ли эскалировать тикет
get_random_escalation_type <- function() {
skill <- get_skill_by_id()
is_spam <- get_attribute(env, "is_spam") == 1
escalation_times <- get_attribute(env, "escalation_times")
if (escalation_times >= 6 || is_spam) {
return(0)
}
multiplier <- escalation_number_probability_multiplier[escalation_times + 1]
inline_escalation_prob <- multiplier * skill$inline_escalation_probability
outline_escalation_prob <- multiplier * skill$outline_escalation_probability
no_escalation_prob <- 1 - inline_escalation_prob - outline_escalation_prob
escalation_type <- base::sample(
c(0, 1, 2),
size = 1,
prob = c(no_escalation_prob, inline_escalation_prob, outline_escalation_prob)
)
return(escalation_type)
}
# Изменить скилл при эскалации внутри линии
get_skill_by_escalation <- function() {
skill_id <- get_attribute(env, "skill_id")
escalation_type <- get_attribute(env, "escalation_type")
if (escalation_type == 1) {
return(get_random_skill_id())
} else {
return(skill_id)
}
}
# Увеличить счетчик эскалаций
get_escalation_times_increment <- function() {
escalation_type <- get_attribute(env, "escalation_type")
escalation_times <- get_attribute(env, "escalation_times")
if (escalation_type > 0) {
return(escalation_times + 1)
}
return(escalation_times)
}
# Нужно ли по новой встать в очередь для обработки
get_should_rollback <- function() {
escalation_type <- get_attribute(env, "escalation_type")
return(escalation_type > 0)
}
# Время обработки в зависимости от того, спам или не спам
get_processing_time <- function() {
skill <- get_skill_by_id()
is_spam <- get_attribute(env, "is_spam") == 1
escalation_type <- get_attribute(env, "escalation_type")
if (is_spam) {
return(skill$spam_processing_time / 60)
}
if (escalation_type == 2) {
return(outline_avg_processing_time / 60)
}
skill_processing_time_data <- load_skill_weighted_processing_times(skill$name, 'new')
processing_time <- base::sample(
x = skill_processing_time_data$processing_times,
size = 1,
prob = skill_processing_time_data$weights
)
return(processing_time / 60)
}
# Определить количество агентов в зависимости от смены
get_currernt_agents_count <- function() {
simulation_day_time <- simmer::now(env) %% day
available_workshifts <- workshift %>%
filter(start <= simulation_day_time & end >= simulation_day_time)
return(sum(available_workshifts$count))
}
ticket_trajectory <- trajectory("Ticket processing") %>%
# Инициализация тикета (выполняется один раз для тикета)
set_attribute("skill_id", get_random_skill_id) %>%
set_attribute("first_skill_id", function() get_attribute(env, "skill_id")) %>%
set_attribute("is_spam", get_random_is_spam) %>%
set_attribute("escalation_times", 0) %>%
set_attribute("escalation_type", 1) %>%
# Повторный проход по тикету при эскалации
set_capacity("agent_inline", get_currernt_agents_count) %>%
set_attribute("processing_time", get_processing_time) %>%
branch(
option = function() get_attribute(env, "escalation_type"),
continue = TRUE,
trajectory("Inline processing") %>%
seize("agent_inline", 1) %>%
timeout_from_attribute("processing_time") %>%
release("agent_inline", 1),
trajectory("Outline processing") %>%
seize("agent_outline", 1) %>%
timeout_from_attribute("processing_time") %>%
release("agent_outline", 1)
) %>%
set_attribute("escalation_type", get_random_escalation_type) %>%
set_attribute("escalation_times", get_escalation_times_increment) %>%
set_attribute("skill_id", get_skill_by_escalation) %>%
simmer::rollback(6, check = get_should_rollback)
plot(ticket_trajectory, verbose = FALSE)
# Generate tickets
env %>%
add_generator("ticket", ticket_trajectory, at(real_tickets_flow)) %>%
add_resource("agent_inline", 0) %>%
add_resource("agent_outline", 200)
# Run simulation
env %>% run(5 * day, progress = progress::progress_bar$new()$update, steps = 20)
# Statistics
arrivals <- get_mon_arrivals(env)
resources <- get_mon_resources(env)
# Время обработки тикета
plot(arrivals, metric = "activity_time")
# Время ожидания в очереди
plot(arrivals, metric = "waiting_time")
# Общее время нахождения тикета в системе
plot(arrivals, metric = "flow_time")
# Количество агентов, обрабатывающих тикеты
plot(resources, metric = "usage", items = "server", steps = TRUE)
# Количество тикетов в очереди
plot(resources, metric = "usage", items = "queue", steps = TRUE)
# Нагрузка на агентов
plot(resources, metric = "utilization")
source('~/Desktop/simulation/queuing-system.R', echo=TRUE)
summary(resources)
# # Statistics
arrivals <- get_mon_arrivals(env)
resources <- get_mon_resources(env)
# Нагрузка на агентов
plot(resources, metric = "utilization")
# Количество агентов, обрабатывающих тикеты
plot(resources, metric = "usage", items = "server", steps = TRUE)
source('~/Desktop/simulation/queuing-system.R', echo=TRUE)
# Statistics
arrivals <- get_mon_arrivals(env)
resources <- get_mon_resources(env)
# Количество агентов, обрабатывающих тикеты
plot(resources, metric = "usage", items = "server", steps = TRUE)
# Нагрузка на агентов
plot(resources, metric = "utilization")
skills <- skills_new
skills_type <- 'new'
library(stats)
library(dplyr)
library(simmer)
library(simmer.plot)
library(progress)
source("./data.R")
real_tickets_flow <- get_real_tickets_flow()
skills <- skills_new
skills_type <- 'new'
set.seed(1234)
#
#
# SIMULATION
#
#
env <- simmer("New line config")
# Определить скилл тикета по вероятности
get_random_skill_id <- function() {
skill <- sample_n(skills, size = 1, weight = skills$probability)
return(skill$id)
}
# Получить объект скилла по id
get_skill_by_id <- function() {
skill_id <- get_attribute(env, "skill_id")
return(skills[skills$id == skill_id, ])
}
# Определить, является ли тикет спамом в соответствии с вероятностью по скиллам
get_random_is_spam <- function() {
skill <- get_skill_by_id()
spam_probabiliy <- skill$spam_probabiliy
is_spam <- base::sample(c(0, 1), size = 1, prob = c(1 - spam_probabiliy, spam_probabiliy))
return(is_spam)
}
# Определить, нужно ли эскалировать тикет
get_random_escalation_type <- function() {
skill <- get_skill_by_id()
is_spam <- get_attribute(env, "is_spam") == 1
escalation_times <- get_attribute(env, "escalation_times")
if (escalation_times >= 6 || is_spam) {
return(0)
}
multiplier <- escalation_number_probability_multiplier[escalation_times + 1]
inline_escalation_prob <- multiplier * skill$inline_escalation_probability
outline_escalation_prob <- multiplier * skill$outline_escalation_probability
no_escalation_prob <- 1 - inline_escalation_prob - outline_escalation_prob
escalation_type <- base::sample(
c(0, 1, 2),
size = 1,
prob = c(no_escalation_prob, inline_escalation_prob, outline_escalation_prob)
)
return(escalation_type)
}
# Изменить скилл при эскалации внутри линии
get_skill_by_escalation <- function() {
skill_id <- get_attribute(env, "skill_id")
escalation_type <- get_attribute(env, "escalation_type")
if (escalation_type == 1) {
return(get_random_skill_id())
} else {
return(skill_id)
}
}
# Увеличить счетчик эскалаций
get_escalation_times_increment <- function() {
escalation_type <- get_attribute(env, "escalation_type")
escalation_times <- get_attribute(env, "escalation_times")
if (escalation_type > 0) {
return(escalation_times + 1)
}
return(escalation_times)
}
# Нужно ли по новой встать в очередь для обработки
get_should_rollback <- function() {
escalation_type <- get_attribute(env, "escalation_type")
return(escalation_type > 0)
}
# Время обработки в зависимости от того, спам или не спам
get_processing_time <- function() {
skill <- get_skill_by_id()
is_spam <- get_attribute(env, "is_spam") == 1
escalation_type <- get_attribute(env, "escalation_type")
if (is_spam) {
return(skill$spam_processing_time / 60)
}
if (escalation_type == 2) {
return(outline_avg_processing_time / 60)
}
skill_processing_time_data <- load_skill_weighted_processing_times(skill$name, skills_type)
processing_time <- base::sample(
x = skill_processing_time_data$processing_times,
size = 1,
prob = skill_processing_time_data$weights
)
return(processing_time / 60)
}
# Определить количество агентов в зависимости от смены
get_currernt_agents_count <- function() {
simulation_day_time <- simmer::now(env) %% day
available_workshifts <- workshift %>%
filter(start <= simulation_day_time & end >= simulation_day_time)
return(sum(available_workshifts$count))
}
ticket_trajectory <- trajectory("Ticket processing") %>%
# Инициализация тикета (выполняется один раз для тикета)
set_attribute("skill_id", get_random_skill_id) %>%
set_attribute("first_skill_id", function() get_attribute(env, "skill_id")) %>%
set_attribute("is_spam", get_random_is_spam) %>%
set_attribute("escalation_times", 0) %>%
set_attribute("escalation_type", 1) %>%
# Повторный проход по тикету при эскалации
set_capacity("agent_inline", get_currernt_agents_count) %>%
set_attribute("processing_time", get_processing_time) %>%
branch(
option = function() get_attribute(env, "escalation_type"),
continue = TRUE,
trajectory("Inline processing") %>%
seize("agent_inline", 1) %>%
timeout_from_attribute("processing_time") %>%
release("agent_inline", 1),
trajectory("Outline processing") %>%
seize("agent_outline", 1) %>%
timeout_from_attribute("processing_time") %>%
release("agent_outline", 1)
) %>%
set_attribute("escalation_type", get_random_escalation_type) %>%
set_attribute("escalation_times", get_escalation_times_increment) %>%
set_attribute("skill_id", get_skill_by_escalation) %>%
simmer::rollback(6, check = get_should_rollback)
plot(ticket_trajectory, verbose = FALSE)
# Generate tickets
env %>%
add_generator("ticket", ticket_trajectory, at(real_tickets_flow)) %>%
add_resource("agent_inline", 0) %>%
add_resource("agent_outline", 200)
# Run simulation
env %>% run(5 * day, progress = progress::progress_bar$new()$update, steps = 20)
# Statistics
arrivals <- get_mon_arrivals(env)
resources <- get_mon_resources(env)
View(resources)
install.packages("simmer.optim")
library(devtools)
devtools::install_github("r-simmer/simmer.optim")
library(stats)
library(dplyr)
library(simmer)
library(simmer.plot)
library(progress)
library(devtools)
devtools::install_github("r-simmer/simmer.optim")
source("./data.R")
real_tickets_flow <- get_real_tickets_flow()
skills <- skills_new
skills_type <- 'new'
set.seed(1234)
env = run_simulation()
#
#
# SIMULATION
#
#
run_simulation = function() {
env <- simmer()
# Определить скилл тикета по вероятности
get_random_skill_id <- function() {
skill <- sample_n(skills, size = 1, weight = skills$probability)
return(skill$id)
}
# Получить объект скилла по id
get_skill_by_id <- function() {
skill_id <- get_attribute(env, "skill_id")
return(skills[skills$id == skill_id, ])
}
# Определить, является ли тикет спамом в соответствии с вероятностью по скиллам
get_random_is_spam <- function() {
skill <- get_skill_by_id()
spam_probabiliy <- skill$spam_probabiliy
is_spam <- base::sample(c(0, 1), size = 1, prob = c(1 - spam_probabiliy, spam_probabiliy))
return(is_spam)
}
# Определить, нужно ли эскалировать тикет
get_random_escalation_type <- function() {
skill <- get_skill_by_id()
is_spam <- get_attribute(env, "is_spam") == 1
escalation_times <- get_attribute(env, "escalation_times")
if (escalation_times >= 6 || is_spam) {
return(0)
}
multiplier <- escalation_number_probability_multiplier[escalation_times + 1]
inline_escalation_prob <- multiplier * skill$inline_escalation_probability
outline_escalation_prob <- multiplier * skill$outline_escalation_probability
no_escalation_prob <- 1 - inline_escalation_prob - outline_escalation_prob
escalation_type <- base::sample(
c(0, 1, 2),
size = 1,
prob = c(no_escalation_prob, inline_escalation_prob, outline_escalation_prob)
)
return(escalation_type)
}
# Изменить скилл при эскалации внутри линии
get_skill_by_escalation <- function() {
skill_id <- get_attribute(env, "skill_id")
escalation_type <- get_attribute(env, "escalation_type")
if (escalation_type == 1) {
return(get_random_skill_id())
} else {
return(skill_id)
}
}
# Увеличить счетчик эскалаций
get_escalation_times_increment <- function() {
escalation_type <- get_attribute(env, "escalation_type")
escalation_times <- get_attribute(env, "escalation_times")
if (escalation_type > 0) {
return(escalation_times + 1)
}
return(escalation_times)
}
# Нужно ли по новой встать в очередь для обработки
get_should_rollback <- function() {
escalation_type <- get_attribute(env, "escalation_type")
return(escalation_type > 0)
}
# Время обработки в зависимости от того, спам или не спам
get_processing_time <- function() {
skill <- get_skill_by_id()
is_spam <- get_attribute(env, "is_spam") == 1
escalation_type <- get_attribute(env, "escalation_type")
if (is_spam) {
return(skill$spam_processing_time / 60)
}
if (escalation_type == 2) {
return(outline_avg_processing_time / 60)
}
skill_processing_time_data <- load_skill_weighted_processing_times(skill$name, skills_type)
processing_time <- base::sample(
x = skill_processing_time_data$processing_times,
size = 1,
prob = skill_processing_time_data$weights
)
return(processing_time / 60)
}
# Определить количество агентов в зависимости от смены
get_currernt_agents_count <- function() {
simulation_day_time <- simmer::now(env) %% day
available_workshifts <- workshift %>%
filter(start <= simulation_day_time & end >= simulation_day_time)
return(sum(available_workshifts$count))
}
ticket_trajectory <- trajectory("Ticket processing") %>%
# Инициализация тикета (выполняется один раз для тикета)
set_attribute("skill_id", get_random_skill_id) %>%
set_attribute("first_skill_id", function() get_attribute(env, "skill_id")) %>%
set_attribute("is_spam", get_random_is_spam) %>%
set_attribute("escalation_times", 0) %>%
set_attribute("escalation_type", 1) %>%
# Повторный проход по тикету при эскалации
set_capacity("agent_inline", get_currernt_agents_count) %>%
set_attribute("processing_time", get_processing_time) %>%
branch(
option = function() get_attribute(env, "escalation_type"),
continue = TRUE,
trajectory("Inline processing") %>%
seize("agent_inline", 1) %>%
timeout_from_attribute("processing_time") %>%
release("agent_inline", 1),
trajectory("Outline processing") %>%
seize("agent_outline", 1) %>%
timeout_from_attribute("processing_time") %>%
release("agent_outline", 1)
) %>%
set_attribute("escalation_type", get_random_escalation_type) %>%
set_attribute("escalation_times", get_escalation_times_increment) %>%
set_attribute("skill_id", get_skill_by_escalation) %>%
simmer::rollback(6, check = get_should_rollback)
plot(ticket_trajectory, verbose = FALSE)
# Generate tickets
env %>%
add_generator("ticket", ticket_trajectory, at(real_tickets_flow)) %>%
add_resource("agent_inline", 0) %>%
add_resource("agent_outline", 200)
# Run simulation
env %>% run(5 * day, progress = progress::progress_bar$new()$update, steps = 20)
return(env)
}
# Суммарная нагрузка агентов
get_resources_usage = function(env) {
data <- env %>%
dplyr::group_by(.data$resource, .data$replication) %>%
dplyr::mutate(dt = .data$time - dplyr::lag(.data$time)) %>%
dplyr::mutate(in_use = .data$dt * dplyr::lag(.data$server / .data$capacity)) %>%
dplyr::summarise(utilization = sum(.data$in_use, na.rm = TRUE) / sum(.data$dt, na.rm=TRUE)) %>%
dplyr::summarise(Q25 = stats::quantile(.data$utilization, .25),
Q50 = stats::quantile(.data$utilization, .5),
Q75 = stats::quantile(.data$utilization, .75))
return(data)
}
env = run_simulation()
usage = get_resources_usage(env)
resources <- get_mon_resources(env)
usage = get_resources_usage(resources)
View(usage)
